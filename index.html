<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Alden Docs</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
      <h1>Building A Keyboard From The Ground Up</h1>
      <img src="assets/keyboard_gif.gif" alt="gif of keyboard spinning" class="gif" >
      <p>
        I for one, have faith in my thumbs; more faith than modern keyboard designs do, it seems. 
        While I was typing away one day, I looked down at my fingers hammering away, each one with
        a job, each one contributing to the task at hand. Sure some fingers had more important rolls
        than others, but everyone was getting involved. Except for my right thumb. My right thumb just
        sat there, poised over the keyboard ready to participate, but never called to action. 
        I thought to myself -- "one extra wide key for two digits? It can't be optmimal. -- so I set 
        out to see for myself. The only question was, what keys should fill the new spaces? As someone
        who spends most of their time writing in languages that use the
        "[]{}=+-_" set of keys all of the time, they seemed like the obvious choice. While I was at 
        it, I had one more optimization I wanted to implement. I am a big fan of VIM. I am certainly
        not an expert. However, the tricks that I have picked up, are hard to live without. I find 
        myself typing "kkkkjjjlll" all of the time in text documents and emails. Since I was planning
        on making a minimal footprint, multilayered keyboard, I decided to replace the "hjkl" keys 
        with the arrow keys on the second layer.
      </p> 
       <h2>Software Design</h2>
          <h4>Core USB Functionality</h4>
          <p>
          When I originally started researching this project I came across similar work done by <a href = "https://github.com/kmani314/ATMega32u4-HID-Keyboard"> Krishna Mani</a>
          which implemented the core USB functionality I needed for
          the 32u4 board. Their repository goes into some detail on how the USB section works, and also links to other extrememly helpful sources, so I wont repeat
          that information here. However, I will clarify one thing that caused me confusion. The CPU in the 32u4 is connected to the USB device via
          dual port FIFO RAM. This is why you'll see the same memory location -- i.e. UEDATX -- being written to consecutivly, seemingly clobbering the previosly
          written data.
          </p>

          <h4>Reading Key Data</h4>
          <p>
          This keyboard is based on PISO shift registers rather than a scanning matrix. Given the relatively slow clock of the CPU, we do
          not have to worry about timing in regards to the register's functions.The maximum transition period for the shift register is 45 ns, and
          the best case senerio for the 32u4 is 62.5 ns per operation. So,  there is no worry of data loss between switching the registers from input to output.
          </p>

          <p>
          Each of the three registers have their control lines tied together so that they can
          be controlled in lock step by a single GPIO pin. The registers read in the current state of the keyboard and then that data is shifted into the CPU.
          The current state and previous states are compared and, in most cases, if change is detected, the appripriate key is added to the HID report and the LED
          animation is triggered. If, however, the key is a layer shift key, nothing is sent to the host and instead the internal key mapping is adjusted 
          appropriately and the LED base color is changed so that the user knows that a layer change has occured.
          </p>
        <h4>LED Timing</h4>
        <p>
          The 32u4 is just barely fast enough to keep up with the timing requirments of the LEDs used in this project. 
          The LED <a href = "https://media.digikey.com/pdf/Data%20Sheets/Lite-On%20PDFs/LTST-E263CEGBK_RevC_7-6-19.pdf">datasheet</a> states the required
          intervals are 300ns and 900ns, with an allowance of (+-) 80ns. With a single cycle of the 32u4 taking 62.5 ns, the processor only has time to excecute
          4.8 instructions during the shorter of the two intervals.
          Using a logic analyzer proved invaluable when writing and debugging this code, because it meant I did not have to inspect the generated assembly and 
          calculate the timing by hand. Also, given that every part of this project was unproven debugging was even more difficult than usual due to the potential
          for both hardware and software bugs to occur at the same time.
          <br>
          The follow section shows simplified examples of the problem faced and measurements of the timing.
        </p>
        <p>
          In this first example, we start off simple and try to send 10 zeros.
        </p>
        <img src="assets/all_zeros_code_clipped2.png" alt="all zeros code" class="images snippit">
        <p>
          This works perfectly fine and we see that the resulting output is within the timing requirments.
        </p>
        <img src="assets/all_zeros_analyzer_clipped.png" alt="all zeros analyzer" class="images analyzer">

        <p>
          Next, we will try and send 10 ones.
        </p>
        <img src="assets/all_ones_problem_code_clipped2.png" alt="all ones problem code" class="images snippit">
        <p>
          This does not work. Even with out any delay, the signal stays low for far too long.
        </p>
        <img src="assets/all_ones_problem_analyzer_clipped.png" alt="all ones problem analyzer" class="images analyzer">
        <p>
          Here we see a solution to the problem. Each time a for-loop executes, the conditional has to be checked and the counter
          has to be incremented. This extra overhead was taking longer than the 300ns we had to work with. The solution I came up
          with was the adjust when this overhead occured.
        </p>
        <img src="assets/all_ones_solution_code_clipped2.png" alt="all ones solution code" class="images snippit">
        <p>
          With the overhead moved into the middle of the loop, the timing is now compliant with the requirments.
          In the full implementation, this code has to have another conditional added in order to 
          adjust when the overhead occurs depending on what value needs to be sent.

        </p>
        <img src="assets/all_ones_solution_analyzer_clipped.png" alt="all ones solution analyzer" class="images analyzer">



      <h2>Electronic Design</h2>
      <h3>Constraints and Desires</h3>
      <img src="assets/pcb_trace_bottom.jpg" alt="pcb traces bottom" class="images pcb">
      <p>
        For this project, I only had a few key requirments in mind. The key layout
        needed to be orhtolinear, I wanted RGB backlighting, and I wanted the smallest footprint 
        I could manage. In regards to the design process, the first two requirments were relatively straight forwared.
        However, reducing the footprint proved to be a challenge. 
        <br>
        Since I
        wanted to have backlit keys, and a good clicky feel, I found myself needing to use through-hole
        switches. Which was all fine and dandy, except it removed the possibility of connecting larger components to 
        the back of the board. I could have made the board taller, or wider, but this would have 
        violated one of my primary design requirments. So, I decided to do something new and implement
        what I call the bi-plane design. Two PCB's stacked on top of each other with connections at the origin of
        each signal. I could have used a ribbon cable to
        connect the two boards, but again this added more width and height. Further, the bi-plane design provided 
        structrual stability to the second board removing the need for additional mounting points.
      </p>

        <img src="assets/pcb_trace_top.jpg" alt="mcu mounting spikes" class="images pcb">

             <p>
        Another oddity in this design is the integration of an entire pre-assembled development board
        onto the PCB. The motivation behind this decision was the desire to minimize hardware debugging at 
        all costs. I don't have enough experince on the hardware side of things to be confident that novel 
        power/timing circuity of my design, would have worked on the first try. Adding 3mm to the 
        overall thickness in order to save potentially months of time, seemed like the obvious choice. 
      </p>
        <p>
          Although this idea worked really well in the end, it took a bit of experiementing to get a good connections on all
          of the pads. Strong surface tension kept my from applying solder through the header holes, and a slight curve in the board
          kept me from first applying solder balls to the pads and then attaching the board. What worked in the end was using anchoring pins to
          facilitate the connection between the pads and the development board.
        </p>

        <img src="assets/mcu_mounting_spikes.jpg" alt="pcb traces top" class="images hard">
        <h3>Assembly Proccess</h3>
        <p>
          A small blob of solder was added to the end of each pin before being placed
          through the header holes. Then the pin was heated and more solder was added, ensuring a secure connection
          to both boards.
        </p>
        <p>
          This experimentation also lead to a perfect solution to a previouslt unaddressed problem. Due to the development board being
          sandwiched between the two PCBs, I did not have any access to the pins after assembly for further dubugging and software modifications.
          However, bending the anchoring pins over and wrapping them in a little heat shrink created perfect programming hooks.
        </p>

        <img src="assets/pin_hooks.jpg" alt="hooks for programming" class="images hard">

        <img src="assets/programming_assembled.jpg" alt="accessing hooks after assembly" class="images hard">
        <h3>The Hair Follicle Technique</h3>
        <p>
          The assembly proccess for most of the other components was relatively common, except for the implementation of 
          the previously mentioned bi-plane design. Although not complicated, the Hair Follical Technique was an interesting procedure.
          First, long strands of wire were soldered to the top board.         
        </p>
        <img src="assets/spaghetti_tech.jpg" alt="spaghetti tech" class="images hard">
        <p>
          Then, these long wires were threaded into the bottom board one row at a time. 
        </p>
        <img src="assets/layer_two_s2.jpg" alt="step two in assembly process" class="images hard">
        <p>
          The board was slowly tilted and lowered, while more wires were threaded.
        </p>
        <img src="assets/layer_two_s3.jpg" alt="step three in assembly process" class="images hard">
        <img src="assets/layer_two_s4.jpg" alt="step four in assembly process" class="images hard">
        <img src="assets/layer_two_s5_alt.jpg" alt="step five in assembly process alt 2" class="images hard">
           <h2>Retrospective</h2>
      <p>
        If I were to do this project again, there are a few major changes I would make
      </p>
      <p>
      Firstly, I would not use 0402 components. They are just too small to handle and I had plenty of room to use a larger package. Here is a picture of the resistors
      next to some Morton salt crystals.
      </p>
        <img src="assets/resistor_salt.jpg" alt="Image of resistor on rice" class="images hard">
        <p>
          In order to work with these components I needed to use a USB microscope in order to place them.
        </p>
        <img src="assets/initial_setup.jpg" alt="initial setup" class="images hard">
        <p>
          Secondly, I would change which GPIO pins the shift registers are connected to. Instead of using IO pins that are physically
          next to each other, I would have used GPIO pins that are connected sequentially in memory. This would have allowed me to use a bit mask
          to read all of the pin values at once instead of reading each individually.
        </p>
        <img src="assets/led_gif.gif" alt="displaying led" class="gif">
  </body>
</html>
